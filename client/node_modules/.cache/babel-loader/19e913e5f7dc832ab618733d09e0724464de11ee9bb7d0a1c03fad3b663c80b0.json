{"ast":null,"code":"const handleDrill = useCallback(async nodeId => {\n  var _parentNode$position, _parentNode$position2;\n  const isExpanded = expandedNodesRef.current.has(nodeId);\n  if (isExpanded) {\n    removeDescendants(nodeId);\n    setNodes(newNodesRef.current);\n    setEdges(edgesRef.current);\n    return;\n  }\n  const node = await fetchNode(nodeId);\n  if (!node || !node.childrenData) return;\n  const reportName = node.reportName;\n  const nextLevel = parseInt(node.level) + 1 || level + 1;\n  const entries = Object.entries(node.childrenData);\n  const totalChildren = entries.length;\n  const parentNode = newNodesRef.current.find(n => n.id === nodeId);\n  const parentX = (parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$position = parentNode.position) === null || _parentNode$position === void 0 ? void 0 : _parentNode$position.x) || 0;\n  const parentY = (parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$position2 = parentNode.position) === null || _parentNode$position2 === void 0 ? void 0 : _parentNode$position2.y) || 0;\n  const horizontalSpacing = 220;\n  const verticalSpacing = 150;\n\n  // Base Y is pushed down for all children (tree layout)\n  const baseY = parentY + verticalSpacing;\n  // Spread children horizontally\n  const startX = parentX - (totalChildren - 1) * horizontalSpacing / 2;\n  entries.forEach(([childId, childLabel], index) => {\n    const childX = startX + index * horizontalSpacing;\n    const childY = baseY;\n    edgesRef.current.push({\n      id: `e-${nodeId}-${childId}`,\n      source: nodeId,\n      sourceHandle: 'a',\n      target: childId,\n      targetHandle: 'a'\n    });\n    newNodesRef.current.push({\n      id: childId,\n      type: 'customNode',\n      position: {\n        x: childX,\n        y: childY\n      },\n      data: {\n        label: childLabel.label,\n        id: childId,\n        reportName: reportName,\n        hasChildren: childLabel.hasChildren,\n        childrenNum: childLabel.childrenNum,\n        expanded: false,\n        onDrill: () => handleDrill(childId)\n      }\n    });\n  });\n  expandedNodesRef.current.add(nodeId);\n  newNodesRef.current = newNodesRef.current.map(n => n.id === nodeId ? {\n    ...n,\n    data: {\n      ...n.data,\n      expanded: true\n    }\n  } : n);\n  const uniqueNodes = Array.from(new Map(newNodesRef.current.map(n => [n.id, n])).values());\n  const uniqueEdges = Array.from(new Map(edgesRef.current.map(e => [e.id, e])).values());\n  setNodes(uniqueNodes);\n  setEdges(uniqueEdges);\n  setLevel(nextLevel);\n  const subtreeNodeIds = [nodeId, ...entries.map(([childId]) => childId)];\n  const subtreeNodes = newNodesRef.current.filter(n => subtreeNodeIds.includes(n.id));\n  const bounds = computeBounds(subtreeNodes);\n  if (bounds && reactFlowInstance.current) {\n    reactFlowInstance.current.fitBounds(bounds, {\n      padding: 0.4,\n      maxZoom: 1.5\n    });\n  }\n}, [level, reactFlowInstance]);","map":{"version":3,"names":["handleDrill","useCallback","nodeId","_parentNode$position","_parentNode$position2","isExpanded","expandedNodesRef","current","has","removeDescendants","setNodes","newNodesRef","setEdges","edgesRef","node","fetchNode","childrenData","reportName","nextLevel","parseInt","level","entries","Object","totalChildren","length","parentNode","find","n","id","parentX","position","x","parentY","y","horizontalSpacing","verticalSpacing","baseY","startX","forEach","childId","childLabel","index","childX","childY","push","source","sourceHandle","target","targetHandle","type","data","label","hasChildren","childrenNum","expanded","onDrill","add","map","uniqueNodes","Array","from","Map","values","uniqueEdges","e","setLevel","subtreeNodeIds","subtreeNodes","filter","includes","bounds","computeBounds","reactFlowInstance","fitBounds","padding","maxZoom"],"sources":["/Users/khalidabourkia/Desktop/diagram/client/src/components/KPIDiagram.jsx"],"sourcesContent":["const handleDrill = useCallback(\n  async (nodeId) => {\n    const isExpanded = expandedNodesRef.current.has(nodeId);\n\n    if (isExpanded) {\n      removeDescendants(nodeId);\n      setNodes(newNodesRef.current);\n      setEdges(edgesRef.current);\n      return;\n    }\n\n    const node = await fetchNode(nodeId);\n    if (!node || !node.childrenData) return;\n\n    const reportName = node.reportName;\n    const nextLevel = parseInt(node.level) + 1 || level + 1;\n    const entries = Object.entries(node.childrenData);\n    const totalChildren = entries.length;\n\n    const parentNode = newNodesRef.current.find((n) => n.id === nodeId);\n    const parentX = parentNode?.position?.x || 0;\n    const parentY = parentNode?.position?.y || 0;\n\n    const horizontalSpacing = 220;\n    const verticalSpacing = 150;\n\n    // Base Y is pushed down for all children (tree layout)\n    const baseY = parentY + verticalSpacing;\n    // Spread children horizontally\n    const startX = parentX - ((totalChildren - 1) * horizontalSpacing) / 2;\n\n    entries.forEach(([childId, childLabel], index) => {\n      const childX = startX + index * horizontalSpacing;\n      const childY = baseY;\n\n      edgesRef.current.push({\n        id: `e-${nodeId}-${childId}`,\n        source: nodeId,\n        sourceHandle: 'a',\n        target: childId,\n        targetHandle: 'a',\n      });\n\n      newNodesRef.current.push({\n        id: childId,\n        type: 'customNode',\n        position: { x: childX, y: childY },\n        data: {\n          label: childLabel.label,\n          id: childId,\n          reportName: reportName,\n          hasChildren: childLabel.hasChildren,\n          childrenNum: childLabel.childrenNum,\n          expanded: false,\n          onDrill: () => handleDrill(childId),\n        },\n      });\n    });\n\n    expandedNodesRef.current.add(nodeId);\n    newNodesRef.current = newNodesRef.current.map(n =>\n      n.id === nodeId\n        ? {\n            ...n,\n            data: { ...n.data, expanded: true },\n          }\n        : n\n    );\n\n    const uniqueNodes = Array.from(new Map(newNodesRef.current.map((n) => [n.id, n])).values());\n    const uniqueEdges = Array.from(new Map(edgesRef.current.map((e) => [e.id, e])).values());\n\n    setNodes(uniqueNodes);\n    setEdges(uniqueEdges);\n    setLevel(nextLevel);\n\n    const subtreeNodeIds = [nodeId, ...entries.map(([childId]) => childId)];\n    const subtreeNodes = newNodesRef.current.filter(n => subtreeNodeIds.includes(n.id));\n    const bounds = computeBounds(subtreeNodes);\n\n    if (bounds && reactFlowInstance.current) {\n      reactFlowInstance.current.fitBounds(bounds, {\n        padding: 0.4,\n        maxZoom: 1.5,\n      });\n    }\n  },\n  [level, reactFlowInstance]\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}